\chapter{Case Study}
\label{ch:case_study}
With an understanding of the prototype's architecture from chapter \ref{ch:implementation}, this chapter dives into the test cases that \prototype{} was put through during the final review from section \ref{sec:action_research_final_meeting}. This chapter describes the context of the case study, how the system was prepared, the tests executed, and how everything was evaluated.

% A structured, factual description of how Masuta was applied in a concrete setting and what was observed during its use.

% Case Context
\section{Case Context}
\prototype{} was put to the test by two domain experts within the realm of enterprise architecture management. This ensured that the questions being asked of the system mirrored a real world setting. The goal of the conducted case study was to evaluate the final system end-to-end and compare its results to a similar, mainstream system. The conducted tests were done in a qualitative and explorative manner, meaning that the focus of the case study was placed on the system's usefulness and perceived value from the experts' point of view.

This qualitative approach was deemed appropriate, as the system was developed as a proof of concept to support enterprise architects in their daily doing. A quantitative test scenario was not considered because the prototype was not developed with explicit quantitative requirements, for example response times within \textit{x} seconds. The practitioners interacted with both \prototype{} and Rovo in parallel while actively comparing results for similar prompts. The comparison was meant to reveal strengths and weaknesses within \prototype{}.

% System Setup and Data
\section{System Setup and Data}
The finished prototype system as described in chapter \ref{ch:implementation} was used throughout. \prototype{} was installed on both practitioners computers and came out of the box with the SpeedParcel example dataset and the empty playground database which only contained the textbook knowledge. All components of \prototype{}, with the exception of the LLM, ran on the local environments of the practitioners' computers.

In order to simulate a real world setting, the enterprise architecture for the examination office of Frankfurt University of Applied Science was used. This architecture included several diagrams within the Archi modeling tool, ranging from high-level process landscapes to detailed views of examination preparation, thesis handling, certification assurance, and IT systems used by the examination office. Models were exported into XML format and read into \prototype{}'s playground database as described in section \ref{sub:xml_parser} and appendix section \ref{appendix:instructions:import}. Frankfurt University of Applied Science's architecture is described in German. The imported data from the examination office's architecture diagrams contained a total of 92 nodes and 152 edges.

Parallel to \prototype{}, Rovo was being used with the same ingested architecture data loaded into Confluence. This allowed the practitioners to test the same dataset with a second system. It included the same documentation and architecture data as found in Archi. 

% Case Execution
\section{Case Execution}
What did users actually do?
How questions were asked
Categories of questions (your 3 levels)
Who asked which type of question
Sequence:
- User prompt
- Schema call
- Retrieval
- Cypher generation
- Answer
- Rovo comparisson

You can include:
- Representative example questions
- Short transcripts (possibly anonymized)
- No judgment


% Observed System Behavior
\section{Observed System Behavior}
What did the system output or do?
Put here:
- Correct answers
- Empty result sets
- Hallucinated outputs
- Cypher generation attempts
- Hardcoded Cypher cases
 Read-only write attempts
- Latency observations
- Differences between expert vs. novice prompts
Example: “In several cases, the system generated Cypher queries that did not reference the retrieved graph elements but instead returned static text.”

% Summary of Case Observations
\section{Summary of Case Observations}
Bullet-point summary of:
- What was observed
- What patterns appeared
No evaluation language
Examples:
“Successful retrieval occurred primarily when node types were explicitly mentioned.”
“Schema ambiguity frequently led to empty result sets.”


----------------------------------------------


What we did with the finished prototype and how we tested it. Prompts we used, cases we built, edge cases, etc.

show some test cases here. break down an answer like "i want to remove the application StatManPlus. What do i have to look out for as an enterprise architect?". the returned answer goes into a lot of depth as this is a level 3 question. break down the result of the query and how the result pulls information about the application but also pulls information from the Lehrbuch database.


Idea: create a list of questions over each category with expected answers and see how it performs. also run x amount of experiments and see how many errors came up (e.g. cypher errors) and count the percent of answers that were perfect, good but could be improved, and wrong / faulty.

\begin{figure}[h]
\centering
\makebox[\textwidth][c]{%
  \includegraphics[width=1\textwidth]{./images/masuta_screenshot_question_answer_1.png}
}
\label{fig:masuta_screenshot_statmanplus}
\caption{Raw response returned from the Cypher in listing \ref{lst:cypher-statmanplus}. Notice that the response contains both information about the applications themselves as well as textbook information on enterprise architecture management (right-most column).}
\end{figure}



\begin{lstlisting}[style=cypherstyle, label={lst:first_time_setup},caption={Cypher query to retrieve application impact and decommission guidance}]
MATCH (a:Application {name: 'StatManPlus'})
OPTIONAL MATCH (a)-[:SUPPORTS]->(cap:Capability)
WITH a, collect(DISTINCT cap) AS caps
UNWIND (CASE WHEN size(caps) > 0 THEN caps ELSE [NULL] END) AS cap
OPTIONAL MATCH (cap)-[:HAS_CHILD*0..]->(desc:Capability)
WITH a, caps, collect(DISTINCT desc) AS cap_impacted
OPTIONAL MATCH (a)-[:DATA_FLOW]->(outApp:Application)
WITH a, caps, cap_impacted, collect(DISTINCT outApp.name) AS outgoing_apps
OPTIONAL MATCH (inApp:Application)-[:DATA_FLOW]->(a)
WITH a, caps, cap_impacted, outgoing_apps, collect(DISTINCT inApp.name) AS incoming_apps
OPTIONAL MATCH (ch:Chunk)
WHERE toLower(coalesce(ch.text,'')) CONTAINS toLower(a.name)
   OR toLower(coalesce(ch.table_summary,'')) CONTAINS toLower(a.name)
   OR toLower(coalesce(ch.title,'')) CONTAINS toLower(a.name)
   OR toLower(coalesce(ch.definition,'')) CONTAINS toLower(a.name)
WITH a, caps, cap_impacted, outgoing_apps, incoming_apps,
     collect(DISTINCT {key: ch.key, title: ch.title, snippet: ch.table_summary, text: ch.text}) AS app_chunks
OPTIONAL MATCH (guid:Chunk)
WHERE toLower(coalesce(guid.text,'')) CONTAINS 'decommission'
   OR toLower(coalesce(guid.text,'')) CONTAINS 'retire'
   OR toLower(coalesce(guid.text,'')) CONTAINS 'sunset'
   OR toLower(coalesce(guid.title,'')) CONTAINS 'decommission'
   OR toLower(coalesce(guid.title,'')) CONTAINS 'retire'
   OR toLower(coalesce(guid.title,'')) CONTAINS 'sunset'
   OR toLower(coalesce(guid.definition,'')) CONTAINS 'decommission'
   OR toLower(coalesce(guid.definition,'')) CONTAINS 'retire'
   OR toLower(coalesce(guid.definition,'')) CONTAINS 'sunset'
   OR toLower(coalesce(guid.table_summary,'')) CONTAINS 'decommission'
   OR toLower(coalesce(guid.table_summary,'')) CONTAINS 'retire'
   OR toLower(coalesce(guid.table_summary,'')) CONTAINS 'sunset'
WITH a, caps, cap_impacted, outgoing_apps, incoming_apps, app_chunks,
     collect(DISTINCT {key: guid.key, title: guid.title, snippet: guid.table_summary, text: guid.text}) AS guidance_chunks
RETURN a.name AS application,
       [c IN caps WHERE c IS NOT NULL | c.id] AS supported_capability_ids,
       [g IN cap_impacted WHERE g IS NOT NULL | g.id] AS impacted_capability_ids,
       outgoing_apps AS outgoing_data_flows_to_apps,
       incoming_apps AS incoming_data_flows_from_apps,
       app_chunks AS chunks_referencing_application,
       guidance_chunks AS chunks_with_decommission_guidance
\end{lstlisting}



\begin{figure}[h]
\centering
\makebox[\textwidth][c]{%
  \includegraphics[width=1.4\textwidth]{./images/cypher_results_category_3.png}
}
\label{fig:cypher_results}
\caption{Raw response returned from the Cypher in listing \ref{lst:first_time_setup}. Notice that the response contains both information about the applications themselves as well as textbook information on enterprise architecture management (right-most column).}
\end{figure}
