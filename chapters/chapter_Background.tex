\chapter{Terminology and Technology}
\label{ch:background}
This chapter goes in detail on the terminology and technology that will be relevant for the reader to have a foundational understanding of the rest of this thesis. Later chapters will build upon these concepts and pieces of technology.

%%%
% Enterprise Architecture Terminology
%%%
\section{Enterprise Architecture Terminology}
\label{sec:background:terminology}

\subsection{Enterprise Architecture Management}
\label{sub:background:eam}
Enterprise Architecture Management (EAM) can be summarized as being the bridge between the business and IT departments of an enterprise. The goal is to implement information technology that is aligned with the business needs of the company. This is in contrast to the IT department implementing information technology for the sake of implementing information technology, which people in IT are often fond of doing \cite{ahmed2017motivating}. An unwanted situation would then be when the IT department falls into a siloed way of thinking where they are decoupled from the rest of the company. EAM helps to ensure that the implemented information technology is achieving the right things, namely supporting the business capabilities and processes. \cite[pg.s 2-3]{jung2021masterclass}

Ensuring that the architecture aligns with business needs requires that the business capabilities of the organization are understood. Business capabilities are defined as what the organization is doing, in contrast to a business process which describes how an organization does something. A business capability thus supports achieving the business strategy by enabling the organization in what it does. \cite[pgs. 46-47]{jung2021masterclass}

Core concepts of EAM include maintaining application landscapes, ensuring business capabilities are being enabled through the enterprise's applications, and aligning IT systems with business objectives. The goal is to align IT and business by transforming the as-is architecture into an improved to-be architecture. \cite[pgs. 14-25, 46-50]{jung2021masterclass}

\subsection{Enterprise Architect Role}
\label{sub:background:ea}
The role of an enterprise architect is thus complex, because they are faced with the challenge of preparing, planning, deciding, and supporting the changes necessary to improve the application architecture and business. A core task of the enterprise architect is creating the necessary artifacts by gathering the necessary information and presenting it in the relevant types of documentation. Applying changes to artifacts in a landscape comes with the responsibility of making the changes public and accessible for the respective stakeholders. The enterprise architect is also responsible for maintaining compliance regulations, as not everyone in an enterprise should be able to view this information. Because architecture landscapes are ever changing, the enterprise architect is also faced with the task of maintaining the existing artifacts. This also includes establishing processes and mechanisms to stay on top of the changing organization and stakeholder requirements. Lastly, the enterprise architect is faced with organizing this process. They are responsible for selecting the right tooling to manage the architecture, organize EAM team, and embed enterprise architecture in governance mechanisms. \cite[pg. 152-154]{jung2021masterclass}

\subsection{Architecture Diagrams and Tools}
Enterprise architects deal with various artifacts, many of which are architecture diagrams. Common architecture diagrams include business capability maps, application landscapes, business support matrixes, and business object models, to name a few. Each of these diagrams serves its own purpose in documenting an existing as-is architecture or an improved to-be architecture. For example, a business capability map gives an overview of the capabilities that an enterprise fulfills. This map breaks capabilities down from a level 1 capability, which is more high level, down to more detailed capabilities of level \textit{n}. Application landscapes are used in order to give an overview of which applications are being used throughout the enterprise, often grouped in to functional categories. \cite[pg. 53, 76]{jung2021masterclass} Combining the two results in a business support matrix, where the cross section between an application and capability indicates whether or not the application enables the capability. This type of matrix allows enterprise architects to maintain an overview of which capabilities are being covered by which applications, if there are redundancies, applications which are being overly relied on, or even uncovered capabilities. \cite{schlor2018analysis}

Various tools exist in order to maintain such architecture diagrams. The modeling languages ArchiMate is a common practice for graphical representation of an enterprise's architecture. The software tool Archi builds upon the ArchiMate modeling language and offers a UI for modeling enterprise architectures. \cite{archi_tool}

The in this section described concepts will be relevant throughout the remainder of this research.

%%%
% Technology
%%%
\section{Technology}
\label{sec:background:technology}
The following descriptions of technologies will help the reader to later understand the implementation details. They serve as a high-level, but sufficient, description of each.


\subsection{Large Language Models (LLM)}
\label{sub:background:llms}
A Large Language Models (LLM)

LLMs are capable of supporting in language-related tasks where text needs to be generated, translated, summarized, analysed, or questions answered \cite{hadi2023large}.

\cite{singhal2023large} describes what llms are and why they are not good with domain specific information and how that causes them to hallucinate.

\cite{wan2025prompting} describes what hallucinating is.


\subsection{Graph Databases, Neo4j, Cypher, and Knowledge Graphs}
\label{sub:background:graphdb}
A graph database is a special type of database which represents its data via nodes and edges. Via this structure, it is able to represent entities and the relationships between them. \cite[pg. 1]{robinson2015graph} For example, a single business capability may be represented as one node, an application as another node, and a relationship between the two with the information of how the application supports this capability. This structure enables graph databases to build real world models that closely resemble the real world and map closely to the domain \cite[pg. 6 and 38]{robinson2015graph}.

A key feature of graph databases is the possibility to traverse the graph. As opposed to relation databases, where an index lookup would be necessary, graph databases allow neighboring nodes to be discovered. This is an advantage when attempting to find information related to a looked up entity. \cite[pgs. 34-35]{van2014learning}

A popular and open source implementation for graph databases is Neo4j \cite{neo4j_2026}. It is a native graph database, meaning it directly stores direct references to adjacent nodes \cite[pgs. 149-150]{robinson2015graph} This allows Neo4j to execute queries in milliseconds \cite{robinson2015graph}. Another main advantage of Neo4j is its features to visually interact with the graph via its Neo4j Desktop application or web based tool.  \cite{van2014learning} This gives the user the option to display the nodes and edges within the graph. Finally, there are a variety of Neo4j libraries that extend its features. One such library is Awesome Procedure on Cypher (APOC), which extends Neo4j to allow specific procedures and functions. Relevant features include retrieving schema information and converting data. \cite{neo4j_apoc_meta_schema, neo4j_apoc_load_xml} 

Within this prototype, Neo4j is implemented as a standalone server and is accessed by the prototype via Cypher queries \cite[pgs. 27 and 77]{robinson2015graph}. Cypher enables access to the knowledge graph through specific patterns that match the data. Data can be added, read, and deleted via Cypher. Queries may match data exactly or specify a matching pattern to find similar or related nodes. This is done by declaring the pattern of how the graph should be traversed and letting the database decide how to go about the retrieval. \cite[pg. 27]{robinson2015graph}\cite[pg. 49]{van2014learning}

A simple example of Cypher can be seen in listing \ref{lst:cypher_simple_example}. This Cypher retrieves all capabilities and the corresponding applications that support them. This exemplifies the structure of how two nodes (application and capability) are connected via a relationship (supports).

% Cypher Example
\begin{lstlisting}[style=cypherstyle, label={lst:cypher_simple_example},caption={A simple Cypher example to retrieve the capabilities supported by applications.}]
MATCH (a:Application)-[:SUPPORTS]->(c:Capability)
RETURN c.name AS capability, c.id AS capabilityId
ORDER BY capability
\end{lstlisting}

A knowledge graph is thus a graph database composed of various relationships to represent a real world structure or network, as found in enterprise architecture diagrams. \cite{wang2017knowledge} Building such a knowledge graph and inferring information from it is a central concept within this research.

\subsection{Retrieval-Augmented Generation (RAG)}
\label{sub:background:rag}
Retrieval-augmented generation (RAG) aims to reduce hallucinations by retrieving relevant information from an external database, such as a knowledge graph, and incorporating that information into the response generation process. \cite{zhao2026retrieval, lewis2020retrieval}

Although LLMs contain basic knowledge within the realm of enterprise architecture management, it may not be sufficiently broad enough or in depth to  answer domain- or organization-specific questions. Furthermore, generally trained LLMs do not have access to proprietary information about an enterprise's architecture. As a result, prompting a detailed question related to enterprise architecture or organization-specific data can lead to hallucinations. \cite{lewis2020retrieval} This is a known challenge that can be overcome by implementing RAG.

RAG offers increased flexibility, as the underlying database can be updated with more information without requiring the language model to be retrained. \cite{zhao2026retrieval}

\subsection{Model Context Protocol (MCP)}
\label{sub:background:mcp}
Modern AI applications are typically designed to be connected with further external tools and services, such as a Neo4j database, in order to allow the AI to xyz to do. However, this brings the challenge with it that the developers of the proprietary application must manually define interfaces in order to connect their AI application to these external services. If the AI application is to be connected with \textit{n} external services, then it needs \textit{n} custom-built connections; one for each service. This comes with a lot of overhead, makes interoperability difficult to achieve, and can hinder long-term maintainability of a system. \cite{hou2025model, anthropic_mcp_2025}

This is where the Model Context Protocol (MCP), developed by Anthropic and released in 2024, comes into play. It standardizes the interface between an AI application and its connected external services by defining a structured protocol for tool discovery, invocation, and result handling. This allows a secure, two-way connection between the AI application and external tools. \cite{anthropic_mcp_2025} With an MCP server sitting between the MCP client (the AI application) and the external service, the MCP client only needs to communicate with the standardized MCP interface \cite{hou2025model}. 

Imagine an MCP client which leverages several external services such as an e-mail provider and calendar application. If a user prompt is sent to the MCP client with the request to create a calendar entry and send the calendar invite per email, then it must decide which of the external tools to invoke in order to fulfil this request. Based on the user's prompt, the MCP client decides which tool exposed by the MCP server should be invoked in order to fulfill the request. The MCP server is then able to invoke the API calls to these external services in order to fulfil the request, i.e. it is able to call the calendar application's API to create the calendar entry and then call the e-mail provider's API to send out the calendar invite. The results are then sent back to the MCP client. \cite{hou2025model} Without the MCP server, the AI application would have to have manually written interfaces to communicate with and handle the e-mail provider's API and the calendar application's API. 

The MCP server is able to offer this agnostic connection to external services, such as an e-mail provider or calendar application, by requiring the tool's providers to explicitly implement their services as MCP-compatible tool interfaces \cite{hou2025model}. There are many pre-built MCP servers offered that allow standardized communication to specific external tools. For example, Neo4j has an official, open source MCP Server. As described later in section \ref{sub:mcp}, this is the MCP server implemented for the prototype within this research. \cite{neo4j_mcp_2025}
